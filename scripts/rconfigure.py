import os
import sys
import shutil
import subprocess
import platform

extensions = ['parquet','core_functions']

# check if there are any additional extensions being requested
if 'DUCKDB_R_EXTENSIONS' in os.environ:
    extensions = extensions + os.environ['DUCKDB_R_EXTENSIONS'].split(",")

unity_build = 20
if 'DUCKDB_BUILD_UNITY' in os.environ:
    try:
        unity_build = int(DUCKDB_BUILD_UNITY)
    except:
        pass

debug_move_flag = ''
if 'DUCKDB_DEBUG_MOVE' in os.environ:
    debug_move_flag = ' -DDUCKDB_DEBUG_MOVE'

# This requires the mother duckdb repo to be checked out in a parallel directory
# (or in a directory specified by the DUCKDB_PATH environment variable).
# Submodules can't be used because they break R CMD build
if 'DUCKDB_PATH' in os.environ:
    duckdb_path = os.environ['DUCKDB_PATH']
else:
    duckdb_path = os.path.join('../duckdb')

# Extract version information early when DuckDB sources are available
def extract_version_info():
    """Extract version info from duckdb sources if available."""
    pragma_version_path = os.path.join('src', 'duckdb', 'src', 'function', 'table', 'version', 'pragma_version.cpp')
    version = None
    with open(pragma_version_path, 'r', encoding='utf-8') as f:
        for line in f:
            line = line.strip()
            if line.startswith('#define DUCKDB_VERSION'):
                # Extract version string, e.g., from '#define DUCKDB_VERSION "v1.3.3-dev231"'
                parts = line.split('"')
                if len(parts) >= 2:
                    version = parts[1]
                    # Remove 'v' prefix for consistency with R test expectations
                    if version.startswith('v'):
                        version = version[1:]
                    break

    return version

# Generate R file with version information early in the process
def generate_version_r_file(version):
    """Generate R file with hard-coded version information."""
    if version:
        r_version_content = f'''# Generated by rconfigure.py, do not edit by hand
# DuckDB version information

duckdb_version <- "{version}"

# Function to get DuckDB version without establishing a connection
get_duckdb_version <- function() {{
  duckdb_version
}}
'''

        with open(os.path.join('R', 'version.R'), 'w', encoding='utf-8') as f:
            f.write(r_version_content)

sys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), '..', duckdb_path, 'scripts'))
import package_build


def open_utf8(fpath, flags):
    import sys

    if sys.version_info[0] < 3:
        return open(fpath, flags)
    else:
        return open(fpath, flags, encoding="utf8")


extension_list = ""

for ext in extensions:
    extension_list += ' -DDUCKDB_EXTENSION_{}_LINKED'.format(ext.upper())
    extension_list += " -DDUCKDB_BUILD_LIBRARY"

libraries = []
if platform.system() == 'Windows':
    libraries += ['ws2_32']

link_flags = ''
for libname in libraries:
    link_flags += ' -l' + libname

# check if we are doing a build from an existing DuckDB installation
if 'DUCKDB_R_BINDIR' in os.environ and 'DUCKDB_R_CFLAGS' in os.environ and 'DUCKDB_R_LIBS' in os.environ:
    existing_duckdb_dir = os.environ['DUCKDB_R_BINDIR']
    compile_flags = os.environ['DUCKDB_R_CFLAGS'].replace('\\', '').replace('  ', ' ')
    rlibs = [x for x in os.environ['DUCKDB_R_LIBS'].split(' ') if len(x) > 0]

    # use existing installation: set up Makevars
    with open_utf8(os.path.join('src', 'Makevars.in'), 'r') as f:
        text = f.read()

    compile_flags += package_build.include_flags(extensions)
    compile_flags += extension_list

    # find libraries
    result_libs = package_build.get_libraries(existing_duckdb_dir, rlibs, extensions)

    for rlib in result_libs:
        libdir = rlib[0]
        libname = rlib[1]
        if libdir != None:
            link_flags += ' -L' + libdir
        if libname != None:
            link_flags += ' -l' + libname

    text = text.replace('{{ SOURCES }}', '')
    text = text.replace('{{ INCLUDES }}', compile_flags.strip())
    text = text.replace('{{ LINK_FLAGS }}', link_flags.strip())

    # now write it to the output Makevars
    with open_utf8(os.path.join('src', 'Makevars'), 'w+') as f:
        f.write(text)
    exit(0)

if not os.path.isfile(os.path.join(duckdb_path, 'scripts', 'amalgamation.py')):
    print("Could not find amalgamation script!")
    exit(1)

target_dir = os.path.join(os.getcwd(), 'src', 'duckdb')

linenr = bool(os.getenv("DUCKDB_R_LINENR", ""))

(source_list, include_list, original_sources) = package_build.build_package(target_dir, extensions, linenr, unity_build)

# Walk target_dir, find all source and include files, and terminate with newline,
# if not already present
for root, dirs, files in os.walk(target_dir):
    for file in files:
        if file.endswith('.cpp') or file.endswith('.hpp') or file.endswith('.c') or file.endswith('.h') or file.endswith('.cc'):
            filename = os.path.join(root, file)
            with open (filename, "r") as f:
                lines = f.readlines()
                if len(lines) > 0 and lines[-1][-1] != '\n':
                    with open (filename, "a") as fw:
                        fw.write("\n")

# object list, relative paths
script_path = os.path.dirname(os.path.abspath(__file__)).replace('\\', '/')

# remove last component of the path
root_path = os.path.dirname(script_path)

duckdb_sources = [package_build.get_relative_path(os.path.join(root_path, 'src'), x) for x in source_list]
object_list = ' '.join([x.rsplit('.', 1)[0] + '.o' for x in sorted(duckdb_sources)])


# include list
include_list = ' '.join(['-I' + 'duckdb/' + x for x in include_list])
include_list += ' -I' + os.path.join('..', 'inst', 'include')
include_list += ' -Iduckdb'
include_list += extension_list
include_list += debug_move_flag

# add -Werror if enabled
if 'TREAT_WARNINGS_AS_ERRORS' in os.environ:
    include_list += ' -Werror'

# read Makevars.in and replace the {{ SOURCES }} and {{ INCLUDES }} macros
with open_utf8(os.path.join('src', 'Makevars.in'), 'r') as f:
    text = f.read()

text = text.replace('{{ HEADER }}', 'Generated by rconfigure.py, do not edit by hand')
text = text.replace('{{ INCLUDES }}', include_list)
if len(libraries) == 0:
    text = text.replace('PKG_LIBS={{ LINK_FLAGS }}\n', '')
else:
    text = text.replace('{{ LINK_FLAGS }}', link_flags.strip())

# now write it to the output Makevars
with open_utf8(os.path.join('src', 'Makevars'), 'w+') as f:
    f.write(text)

# same dance for Windows
# read Makevars.in and replace the {{ SOURCES }} and {{ INCLUDES }} macros
with open_utf8(os.path.join('src', 'Makevars.in'), 'r') as f:
    text = f.read()

text = text.replace('{{ HEADER }}', 'Generated by rconfigure.py, do not edit by hand')
include_list += " -DDUCKDB_PLATFORM_RTOOLS=1"
text = text.replace('{{ INCLUDES }}', include_list)
text = text.replace('{{ LINK_FLAGS }}', "-lws2_32 $(DUCKDB_RSTRTMGR_LIB)")

# now write it to the output Makevars
with open_utf8(os.path.join('src', 'Makevars.win'), 'w+') as f:
    f.write(text)

# write sources.mk
text = "SOURCES=" + object_list + '\n'

with open_utf8(os.path.join('src', 'include', 'sources.mk'), 'w') as f:
    f.write(text)

# Try to extract version and generate R file
extracted_version = extract_version_info()
generate_version_r_file(extracted_version)
