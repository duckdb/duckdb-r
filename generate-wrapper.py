import shutil
import sys
import pycparser
import tempfile
import urllib.request
import os
import zipfile

# those functions return promises asynchronously since they may block and/or do IO
# async_functions = ['duckdb_open', 'duckdb_open_ext', 'duckdb_close', 'duckdb_connect', 'duckdb_disconnect', 'duckdb_query', 'duckdb_prepare', 'duckdb_execute_prepared', 'duckdb_stream_fetch_chunk', 'duckdb_execute_tasks', 'duckdb_appender_create', 'duckdb_appender_flush', 'duckdb_appender_close', 'duckdb_appender_destroy', 'duckdb_execute_prepared', 'duckdb_extract_statements', 'duckdb_prepare_extracted_statement', 'duckdb_execute_pending']

pointer_wrappers = ['duckdb_appender',
                     'duckdb_config', 'duckdb_connection', 'duckdb_data_chunk', 'duckdb_database', 'duckdb_extracted_statements', 'duckdb_logical_type', 'duckdb_pending_result', 'duckdb_prepared_statement', 'duckdb_value', 'duckdb_vector'] # 'duckdb_arrow', 'duckdb_arrow_array', 'duckdb_arrow_schema', 'duckdb_arrow_stream'

deprecated_functions = []

def typename(decl):
    const = ''
    if hasattr(decl, 'quals') and 'const' in decl.quals:
        const = 'const '
    if isinstance(decl, pycparser.c_ast.TypeDecl):
        return const + typename(decl.type)
    elif isinstance(decl, pycparser.c_ast.PtrDecl):
        return const + typename(decl.type) + '*'
    elif isinstance(decl, pycparser.c_ast.IdentifierType):
        return decl.names[0].replace('_Bool', 'bool')
    else:
       raise ValueError(decl)

class DuckDBHeaderVisitor(pycparser.c_ast.NodeVisitor):
    result = ''
    enum_result = ''
    def visit_TypeDecl(self, node):
        name = node.declname
        if not name.startswith('duckdb_'):
            return

        if isinstance(node.type, pycparser.c_ast.Struct):
            self.result += '{"%s_new", (DL_FUNC) duckdb_r::PointerWrapper<%s, "%s">::Allocate, 0},\n' % (name, name, name)

        elif isinstance(node.type, pycparser.c_ast.Enum):
            self.enum_result += f'\t{name}_enum <- list();\n'
            #            self.types_result += f'export enum {name} {{\n'
            #            self.c_type_to_ts_type[name] = name
            enum_idx = 0
            for enum in node.type.values.enumerators:
                if enum.value is not None:
                    enum_idx = int(enum.value.value)
                self.enum_result += f'\t{name}_enum${enum.name} <- {enum_idx}\n'
                enum_idx += 1

    def visit_FuncDecl(self, node):
       name = None
       ret = typename(node.type)

       args = []
       if isinstance(node.type, pycparser.c_ast.TypeDecl):
           name = node.type.declname
       elif isinstance(node.type, pycparser.c_ast.PtrDecl):
           name = node.type.type.declname
       else:
           raise ValueError(node.type)


       if node.args:
           for p in node.args.params:
               args.append(typename(p.type))

       if name == '__routine':
           return # ??

       if 'replacement' in name:
           return # ??

       if 'delete_callback' in name:
           return # ??

       if 'duckdb_init_' in name:
            return

       if 'table_function' in name:
           return # TODO

       if 'arrow' in name:
           return # TODO

       if name in deprecated_functions:
           return

       print(f"{name}")

       n_args = len(args)
       args.append(f'"{name}"')
       voidstr = ''
       if ret == 'void':
           voidstr = 'Void'
       else:
           args.insert(0, ret)
       arg_str = ', '.join(args)

       fun_name = f"duckdb_r::FunctionWrappers::FunctionWrapper{n_args}{voidstr}<{arg_str}>"
       self.result += '{"%s", (DL_FUNC) %s, %d},\n' % (name, fun_name, n_args)



if __name__ == "__main__":

    with tempfile.TemporaryDirectory() as tmp:
        zip_path = os.path.join(tmp, "libduckdb.zip")
        urllib.request.urlretrieve("https://github.com/duckdb/duckdb/releases/download/v1.0.0/libduckdb-osx-universal.zip", zip_path)
        zip = zipfile.ZipFile(zip_path)
        zip.extract("duckdb.h", tmp)

        os.system("sed -i -e 's/#include <stdlib.h>/#include <stddef.h>/' %s" % os.path.join(tmp, "duckdb.h")) # until 0.10.0 has been released
        os.system("gcc -DDUCKDB_NO_EXTENSION_FUNCTIONS -DDUCKDB_API_NO_DEPRECATED -E -D__builtin_va_list=int %s > %s" % (os.path.join(tmp, "duckdb.h"), os.path.join(tmp, "duckdb-preprocessed.h")))


        ast = pycparser.parse_file(os.path.join(tmp, "duckdb-preprocessed.h"), use_cpp=False)

        v = DuckDBHeaderVisitor()
        v.visit(ast)

        out = open('src/duckdb_r_generated.cpp', 'wb')
        out.write('// This file is generated by generate-wrapper.py, please do not edit\n\n#include "function_wrappers.hpp"\n#include <dlfcn.h>\n#include "duckdb.h"\n\nstatic R_CallMethodDef generated_methods[]= {\n'.encode())
        out.write(v.result.encode())
        out.write('{"duckdb_load_library", (DL_FUNC) duckdb_load_library, 1},{"duckdb_copy_buffer", (DL_FUNC) duckdb_copy_buffer, 2},{"duckdb_adbc", (DL_FUNC) duckdb_adbc, 0},{nullptr, nullptr, 0}};\n\n'.encode())
        out.close()

        out = open('R/enums.R', 'wb')
        out.write('# This file is generated by generate-wrapper.py, please do not edit\n\n'.encode())
        out.write(v.enum_result.encode())
        out.close()
